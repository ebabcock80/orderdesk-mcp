# Implementation Plan: OrderDesk MCP Server + Optional WebUI

**Version:** 1.1  
**Status:** Active Implementation Plan  
**Last Updated:** October 17, 2025  
**Plan Type:** Phased, risk-driven, test-first (no time estimates)

**Companion Documents:**
- [`speckit.constitution`](./speckit.constitution) - Design principles and constraints
- [`speckit.specify`](./speckit.specify) - Technical specification
- [`speckit.clarify`](./speckit.clarify) - Clarification questions (to be answered)

---

## Overview

This plan breaks down the OrderDesk MCP Server + Optional WebUI implementation into **8 sequential phases** (0-7), each with:
- **Clear exit criteria** (measurable, testable outcomes)
- **Risk identification** and mitigation strategies
- **Test-first approach** (write tests before or alongside implementation)
- **Incremental validation** (each phase delivers working functionality)

**No Time Estimates:** This is a risk-driven plan focused on reducing uncertainty incrementally. Complete each phase before moving to the next.

**WebUI is Optional:** Phases 5-6 implement the optional web interface. The server functions fully without WebUI (stdio MCP only).

---

## Phase Dependencies

```
Phase 0 (Bootstrap & CI)
    ↓
Phase 1 (Auth, Storage, Session Context)
    ↓
Phase 2 (Order Read Path & Pagination)
    ↓
Phase 3 (Full Mutation Pipeline)
    ↓
Phase 4 (Ancillary Resources)
    ↓
Phase 5 (Optional HTTP Adapter & WebUI Admin)
    ↑
Phase 1 (can start after P1)
    ↓
Phase 6 (Optional Public Signup)
    ↑
Phase 5 (requires WebUI)
    ↓
Phase 7 (Docs & Examples)
    ↑
Phases 2-6 (after features stabilize)
```

**Critical Path (MCP only):** P0 → P1 → P2 → P3 → P4 → P7  
**Critical Path (with WebUI):** P0 → P1 → P2 → P3 → P4 → P5 → P6 → P7  
**Parallel Opportunities:** 
- P5 can start after P1 (HTTP adapter basics)
- P6 requires P5 completion (signup needs WebUI)
- P7 ongoing after P2 (document as features complete)

---

## Phase 0: Bootstrap & CI

**Goal:** Establish project foundation with CI/CD, containerization, and basic infrastructure.

### Tasks

#### 0.1 Repository Structure
- [ ] Create directory layout per constitution:
  ```
  mcp_server/
  ├── __init__.py
  ├── main.py
  ├── mcp_server.py
  ├── config.py
  ├── auth/
  ├── models/
  ├── routers/
  ├── services/
  └── utils/
  ```
- [ ] Initialize `pyproject.toml` with dependencies:
  - Core: `mcp`, `httpx`, `pydantic`, `sqlalchemy`, `cryptography`
  - Dev: `pytest`, `pytest-asyncio`, `pytest-cov`, `ruff`, `mypy`, `black`
- [ ] Create `.gitignore` (exclude `data/`, `*.db`, `.env`, `__pycache__/`)
- [ ] Create `.env.example` with all env vars documented

#### 0.2 Docker Configuration
- [ ] Write `Dockerfile`:
  - Multi-stage build (builder + runtime)
  - Python 3.11+ slim base
  - Non-root user
  - Health check command
- [ ] Write `docker-compose.yml`:
  - App service with volume mounts
  - Optional Redis service (commented out)
  - Environment variable configuration
- [ ] Test build: `docker build -t orderdesk-mcp-server .`
- [ ] Test run: `docker-compose up`

#### 0.3 CI Pipeline (GitHub Actions)
- [ ] Create `.github/workflows/ci.yml`:
  ```yaml
  name: CI
  on: [push, pull_request]
  jobs:
    lint:
      - ruff check .
      - black --check .
    typecheck:
      - mypy mcp_server/
    test:
      - pytest tests/ --cov=mcp_server --cov-report=term-missing
    build:
      - docker build -t orderdesk-mcp-server .
  ```
- [ ] Configure branch protection (require CI to pass)

#### 0.4 Core Configuration
- [ ] Implement `config.py`:
  - Load env vars with validation
  - Pydantic settings model
  - Sensible defaults
  - Required vars: `MCP_KMS_KEY`
- [ ] Implement `utils/logging.py`:
  - Structured JSON logging
  - Correlation ID middleware
  - Secret redaction filter
  - Log levels (DEBUG, INFO, WARNING, ERROR)

#### 0.5 Common Types & Error Handling
- [ ] Define `models/common.py`:
  ```python
  class MCPError(Exception):
      code: str
      message: str
      details: dict | None
  
  class Result(BaseModel, Generic[T]):
      status: Literal["success", "error"]
      data: T | None
      error: MCPError | None
  ```
- [ ] Define domain exceptions:
  - `OrderDeskError` (base)
  - `ValidationError` (input validation)
  - `AuthError` (authentication/authorization)
  - `ConflictError` (concurrency conflicts)
  - `RateLimitError` (rate limit exceeded)

#### 0.6 Basic MCP Server
- [ ] Implement `mcp_server.py`:
  - stdio transport initialization
  - Tool registration system
  - Error handling and formatting
  - Health check handler (if HTTP enabled)
- [ ] Implement `main.py`:
  - Entry point for stdio mode
  - Graceful shutdown
  - Signal handling

#### 0.7 Health Check Endpoint (if HTTP enabled)
- [ ] Implement `routers/health.py`:
  ```python
  @app.get("/health")
  async def health():
      return {"status": "ok", "version": __version__}
  ```

### Exit Criteria

✅ **Must Pass:**
1. CI pipeline runs successfully (lint, type check, test, build)
2. Docker container builds without errors
3. Container starts and logs structured JSON
4. If HTTP enabled: `GET /health` returns 200 with `{"status": "ok"}`
5. Test coverage > 50% for implemented components
6. Zero linter or type errors

✅ **Validation:**
```bash
# CI validation
git push && gh pr checks

# Docker validation
docker build -t orderdesk-mcp-server .
docker run --rm -e MCP_KMS_KEY=$(openssl rand -base64 32) orderdesk-mcp-server

# Health check (if HTTP)
curl http://localhost:8080/health
```

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| CI complexity slows initial development | Medium | Start with minimal CI (lint + test), add coverage later |
| Docker build time | Low | Use multi-stage builds, layer caching |
| Configuration management fragility | Medium | Use Pydantic for validation, fail fast on missing required vars |

---

## Phase 1: Auth, Storage, Session Context

**Goal:** Implement secure multi-tenant authentication, encrypted storage, and session management.

### Tasks

#### 1.1 Cryptography Service
- [ ] Implement `auth/crypto.py`:
  ```python
  def derive_tenant_key(master_key: str, salt: str) -> bytes:
      """HKDF-SHA256 key derivation"""
  
  def encrypt_api_key(api_key: str, tenant_key: bytes) -> tuple[str, str, str]:
      """AES-256-GCM encryption → (ciphertext, tag, nonce)"""
  
  def decrypt_api_key(ciphertext: str, tag: str, nonce: str, tenant_key: bytes) -> str:
      """AES-256-GCM decryption with tag verification"""
  
  def hash_master_key(master_key: str) -> tuple[str, str]:
      """bcrypt/argon2 hash → (hash, salt)"""
  
  def verify_master_key(master_key: str, hash: str) -> bool:
      """Verify master key against stored hash"""
  ```
- [ ] Write tests: `tests/test_crypto.py`
  - Key derivation is deterministic with same inputs
  - Encryption/decryption roundtrip
  - Wrong key fails decryption
  - Tag verification catches tampering

#### 1.2 Database Models & Migrations
- [ ] Implement `models/database.py`:
  ```python
  class Tenant(Base):
      __tablename__ = "tenants"
      id: str  # UUID
      master_key_hash: str
      salt: str
      created_at: datetime
      updated_at: datetime
  
  class Store(Base):
      __tablename__ = "stores"
      id: str  # UUID
      tenant_id: str  # FK
      store_id: str  # OrderDesk store ID
      store_name: str  # Friendly name
      label: str | None
      api_key_ciphertext: str
      api_key_tag: str
      api_key_nonce: str
      created_at: datetime
      updated_at: datetime
  ```
- [ ] Create database initialization script
- [ ] Write Alembic migrations (if using migrations)
- [ ] Write tests: `tests/test_database.py`
  - Schema creation
  - Constraints enforcement (unique tenant store names)
  - Cascade deletes (tenant → stores)

#### 1.3 Tenant Service
- [ ] Implement `services/tenant.py`:
  ```python
  class TenantService:
      async def authenticate(master_key: str) -> Tenant | None:
          """Verify master key and return tenant"""
      
      async def create_tenant(master_key: str) -> Tenant:
          """Create new tenant (if auto-provision enabled)"""
      
      async def get_tenant_by_id(tenant_id: str) -> Tenant | None:
          """Fetch tenant by ID"""
  ```
- [ ] Write tests: `tests/test_tenant.py`
  - Successful authentication with correct key
  - Failed authentication with wrong key
  - Auto-provision creates tenant on first use (if enabled)
  - Auto-provision fails if disabled

#### 1.4 Store Service
- [ ] Implement `services/store.py`:
  ```python
  class StoreService:
      async def register_store(
          tenant_id: str,
          store_id: str,
          api_key: str,
          store_name: str | None = None,
          label: str | None = None
      ) -> Store:
          """Register new store with encrypted API key"""
      
      async def list_stores(tenant_id: str) -> list[Store]:
          """List all stores for tenant"""
      
      async def get_store(tenant_id: str, store_id: str) -> Store | None:
          """Get store by OrderDesk store ID"""
      
      async def get_store_by_name(tenant_id: str, store_name: str) -> Store | None:
          """Get store by friendly name"""
      
      async def resolve_store(tenant_id: str, identifier: str) -> Store | None:
          """Resolve store by ID or name"""
      
      async def delete_store(tenant_id: str, store_id: str) -> bool:
          """Delete store registration"""
      
      async def get_decrypted_credentials(store: Store, tenant_key: bytes) -> tuple[str, str]:
          """Return (store_id, api_key) decrypted"""
  ```
- [ ] Write tests: `tests/test_stores.py`
  - Store registration encrypts API key
  - List stores for tenant (no leakage)
  - Lookup by name vs ID
  - Resolve handles both name and ID
  - Delete removes store
  - Duplicate store_name rejected
  - Duplicate store_id rejected

#### 1.5 Session Context Manager
- [ ] Implement `services/session.py`:
  ```python
  class SessionContext:
      tenant_id: str | None
      tenant_key: bytes | None
      active_store_id: str | None
      correlation_id: str
      
      def set_tenant(tenant: Tenant, master_key: str):
          """Set active tenant and derive key"""
      
      def set_active_store(store_id: str):
          """Set active store for subsequent calls"""
      
      def get_active_store() -> Store | None:
          """Get active store (if set)"""
      
      def clear():
          """Clear session context"""
  ```
- [ ] Integrate with MCP server (session per connection)
- [ ] Write tests: `tests/test_session.py`
  - Context scoped per session
  - Tenant key derived on set_tenant
  - Active store persists across tool calls
  - Clear resets context

#### 1.6 Rate Limiting
- [ ] Implement `services/rate_limit.py`:
  ```python
  class RateLimiter:
      def __init__(rpm: int = 120):
          """Sliding window rate limiter"""
      
      async def check(tenant_id: str) -> bool:
          """Check if request allowed"""
      
      async def consume(tenant_id: str) -> bool:
          """Consume token, return False if limit exceeded"""
      
      async def reset(tenant_id: str):
          """Reset rate limit (for testing)"""
  ```
- [ ] Write tests: `tests/test_rate_limit.py`
  - Allows requests under limit
  - Blocks requests over limit
  - Sliding window behavior
  - Per-tenant isolation

#### 1.7 MCP Tools: Tenant & Store Management
- [ ] Implement `routers/stores.py`:
  ```python
  @mcp.tool("tenant.use_master_key")
  async def use_master_key(master_key: str) -> Result:
      """Authenticate tenant and establish session"""
  
  @mcp.tool("stores.register")
  async def register_store(
      store_id: str,
      api_key: str,
      store_name: str | None = None,
      label: str | None = None
  ) -> Result:
      """Register OrderDesk store"""
  
  @mcp.tool("stores.list")
  async def list_stores() -> Result:
      """List registered stores"""
  
  @mcp.tool("stores.delete")
  async def delete_store(store_id: str) -> Result:
      """Remove store registration"""
  
  @mcp.tool("stores.use_store")
  async def use_store(identifier: str) -> Result:
      """Set active store by ID or name"""
  
  @mcp.tool("stores.resolve")
  async def resolve_store(identifier: str) -> Result:
      """Resolve store name to ID and credentials (debug tool)"""
  ```
- [ ] Add JSON schemas for all tools
- [ ] Write tests: `tests/test_store_tools.py`
  - Full workflow: authenticate → register → list → use_store → delete
  - Error cases: wrong master key, duplicate store, missing store

### Exit Criteria

✅ **Must Pass:**
1. All 6 tenant/store management tools functional
2. Master key authentication works
3. Store registration encrypts API keys (verified in DB)
4. Store lookup by name resolves correctly
5. Session context persists tenant + active store
6. Rate limiting enforced per tenant
7. Secrets never appear in logs (redaction verified)
8. Test coverage > 80% for auth/storage/session
9. Integration test: full auth → register → list → resolve flow

✅ **Validation:**
```bash
# Unit tests
pytest tests/test_crypto.py tests/test_tenant.py tests/test_stores.py tests/test_session.py -v

# Integration test
pytest tests/test_store_tools.py -v

# Log redaction check
grep -r "api_key" logs/ && echo "FAIL: Secret in logs!" || echo "PASS: No secrets"
```

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Crypto implementation bugs | Critical | Use well-tested libraries (cryptography.io), comprehensive tests |
| Master key leakage in logs | Critical | Implement redaction filter, automated tests for log scrubbing |
| Session state management complexity | High | Use thread-local or async context vars, clear lifecycle |
| Database migration issues | Medium | Test migrations with data, provide rollback scripts |

---

## Phase 2: Order Read Path & Pagination

**Goal:** Implement read-only order operations with full pagination control and caching.

### Tasks

#### 2.1 OrderDesk API Client
- [ ] Implement `services/orderdesk.py`:
  ```python
  class OrderDeskClient:
      def __init__(store_id: str, api_key: str):
          """Initialize with store credentials"""
      
      async def get(endpoint: str, params: dict | None = None) -> dict:
          """GET request with retries"""
      
      async def post(endpoint: str, data: dict) -> dict:
          """POST request with retries"""
      
      async def put(endpoint: str, data: dict) -> dict:
          """PUT request with retries"""
      
      async def delete(endpoint: str) -> dict:
          """DELETE request with retries"""
      
      async def _retry_with_backoff(request_fn, max_retries: int = 3):
          """Retry logic for 429/5xx with exponential backoff + jitter"""
  ```
- [ ] Configure httpx client:
  - Timeout: 30s (configurable)
  - Connection pooling
  - Retry transport for network errors
- [ ] Parse OrderDesk rate limit headers:
  - `X-Tokens-Remaining`
  - `X-Retry-After`
- [ ] Write tests: `tests/test_orderdesk_client.py`
  - Successful GET request
  - Retry on 429 with backoff
  - Retry on 5xx with backoff
  - Headers added correctly (ORDERDESK-STORE-ID, ORDERDESK-API-KEY)
  - Timeout handling

#### 2.2 OrderDesk Models (Pydantic)
- [ ] Implement `models/orderdesk.py`:
  ```python
  class Address(BaseModel):
      first_name: str
      last_name: str
      company: str | None
      address1: str
      address2: str | None
      address3: str | None
      address4: str | None
      city: str
      state: str
      postal_code: str
      country: str
      phone: str | None
  
  class OrderItem(BaseModel):
      id: str
      name: str
      code: str
      price: float
      quantity: int
      weight: float | None
      # ... all fields from OD docs
  
  class Order(BaseModel):
      id: str
      email: str
      shipping_method: str | None
      quantity_total: int
      weight_total: float
      product_total: float
      shipping_total: float
      handling_total: float
      tax_total: float
      discount_total: float
      order_total: float
      payment_type: str | None
      payment_status: str | None
      customer_id: str | None
      source_id: str | None
      folder_id: int
      date_added: datetime
      date_updated: datetime
      shipping: Address
      customer: Address | None
      order_items: list[OrderItem]
      # ... all fields from OD docs
  ```
- [ ] Validate models against actual OrderDesk responses

#### 2.3 Cache Service
- [ ] Implement `services/cache.py`:
  ```python
  class CacheService:
      def __init__(backend: str = "memory", ttl: int = 60):
          """Initialize cache (memory or redis)"""
      
      async def get(key: str) -> Any | None:
          """Get cached value"""
      
      async def set(key: str, value: Any, ttl: int | None = None):
          """Set cached value with TTL"""
      
      async def delete(key: str):
          """Delete cached value"""
      
      async def delete_pattern(pattern: str):
          """Delete all keys matching pattern"""
      
      def make_key(tenant_id: str, store_id: str, resource: str, resource_id: str) -> str:
          """Generate cache key"""
  ```
- [ ] Implement memory backend (default)
- [ ] Write tests: `tests/test_cache.py`
  - Set and get values
  - TTL expiration
  - Delete single key
  - Delete by pattern
  - Key generation format

#### 2.4 Orders Read Tools
- [ ] Implement `routers/orders.py`:
  ```python
  class OrdersListParams(BaseModel):
      store_name: str | None = None
      folder_id: str | None = Field(None, description="OrderDesk folder ID")
      status: str | None = Field(None, description="Order status filter")
      since: datetime | None = Field(None, description="ISO8601 datetime")
      sort: str | None = Field(None, description="Sort: date_added, date_updated")
      limit: int = Field(50, ge=1, le=250, description="Records per page (1-250)")
      page: int = Field(1, ge=1, description="Page number (1+)")
      search: str | None = Field(None, description="Free text search")
      # Add ALL other documented OD params
  
  @mcp.tool("orders.list")
  async def list_orders(params: OrdersListParams) -> Result:
      """List orders with full pagination and filtering control"""
  
  @mcp.tool("orders.get")
  async def get_order(order_id: str, store_name: str | None = None) -> Result:
      """Get single order by ID"""
  ```
- [ ] Add JSON schemas with examples
- [ ] Implement read-through caching:
  - Cache individual orders (15s TTL)
  - Cache list results (15s TTL, key by params hash)
- [ ] Write tests: `tests/test_order_tools.py`
  - List with default pagination
  - List with custom limit/page
  - List with filters (folder_id, status, since)
  - Get single order (hit cache, then API)
  - Pagination edge cases (page beyond results)

#### 2.5 Store Settings Tool
- [ ] Implement `routers/stores.py` addition:
  ```python
  @mcp.tool("store.get_settings")
  async def get_settings(store_name: str | None = None) -> Result:
      """Get store settings and folder structure"""
  ```
- [ ] Cache store settings (300s TTL)
- [ ] Write tests: `tests/test_store_settings.py`
  - Fetch settings (includes folders)
  - Cache behavior

### Exit Criteria

✅ **Must Pass:**
1. `orders.list` functional with all documented parameters exposed
2. `orders.get` functional with caching
3. `store.get_settings` functional (for folder lookups)
4. LLM can control pagination: `limit=25`, `page=2`, etc.
5. Read-through cache working (verified cache hits in logs)
6. Automatic retry on 429 with `X-Retry-After` respected
7. Automatic retry on 5xx with exponential backoff
8. Test coverage > 80% for OrderDesk client and order tools
9. Example requests in `/examples/orders_list.json`, `/examples/orders_get.json`

✅ **Validation:**
```bash
# Unit tests
pytest tests/test_orderdesk_client.py tests/test_order_tools.py -v

# Pagination control test
# LLM can request: limit=25, limit=100, limit=250
pytest tests/test_pagination.py -v

# Cache verification
grep "cache_hit=true" logs/app.log

# Integration test (if env vars set)
pytest tests/integration/test_orders_read.py -v
```

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| OrderDesk rate limits hit during testing | Medium | Implement smart retry, use integration test guards |
| Pagination params differ per resource | Medium | Read OD docs carefully, test each resource type |
| Cache invalidation bugs | Medium | Conservative TTLs (15s), test invalidation patterns |
| Large result sets OOM | Low | Validate max limit (250), warn in docs |

---

## Phase 3: Full Mutation Pipeline

**Goal:** Implement safe order mutations with fetch → mutate → upload pattern and concurrency handling.

### Tasks

#### 3.1 Orders Write Tools (Foundation)
- [ ] Implement `routers/orders.py` additions:
  ```python
  class OrderCreateParams(BaseModel):
      # All order fields (per OD docs)
      pass
  
  @mcp.tool("orders.create")
  async def create_order(order: OrderCreateParams, store_name: str | None = None) -> Result:
      """Create new order in OrderDesk"""
  
  @mcp.tool("orders.update_full")
  async def update_full(order_id: str, order: Order, store_name: str | None = None) -> Result:
      """Replace entire order object (use orders.mutate_full for safety)"""
  
  @mcp.tool("orders.delete")
  async def delete_order(order_id: str, store_name: str | None = None) -> Result:
      """Delete order"""
  ```
- [ ] Invalidate cache on writes:
  - Delete `order:{order_id}`
  - Delete `orders:list:*` (pattern)
- [ ] Write tests: `tests/test_order_writes.py`
  - Create order
  - Update full order (replace)
  - Delete order
  - Cache invalidation verified

#### 3.2 Mutation Engine
- [ ] Implement `services/mutation.py`:
  ```python
  class MutationEngine:
      async def mutate_order(
          orderdesk_client: OrderDeskClient,
          order_id: str,
          mutation: dict | None = None,
          ops: list[Operation] | None = None,
          max_retries: int = 5
      ) -> Order:
          """
          1. Fetch current order
          2. Apply mutation (deep merge) or ops (typed operations)
          3. Upload full order
          4. On conflict: refetch and retry
          """
      
      def apply_mutation(order: Order, mutation: dict) -> Order:
          """Deep merge mutation into order"""
      
      def apply_operations(order: Order, ops: list[Operation]) -> Order:
          """Apply typed operations sequentially"""
  ```
- [ ] Define operation types:
  ```python
  class MoveFolderOp(BaseModel):
      op: Literal["move_folder"]
      destination_folder_id: str
  
  class AddItemsOp(BaseModel):
      op: Literal["add_items"]
      items: list[OrderItem]
  
  class UpdateAddressOp(BaseModel):
      op: Literal["update_address"]
      address_type: Literal["shipping", "billing"]
      address: Address
  
  Operation = MoveFolderOp | AddItemsOp | UpdateAddressOp | ...
  ```
- [ ] Implement conflict detection:
  - Compare `date_updated` timestamps
  - If changed: refetch and retry
  - Exponential backoff: 500ms, 1s, 2s, 4s, 8s
- [ ] Write tests: `tests/test_mutation_engine.py`
  - Deep merge logic
  - Operation application
  - Conflict detection and retry
  - Max retries exceeded error

#### 3.3 Orders Mutate Tool
- [ ] Implement `routers/orders.py` addition:
  ```python
  class OrderMutationParams(BaseModel):
      store_name: str | None = None
      order_id: str = Field(..., description="OrderDesk order ID")
      mutation: dict | None = Field(None, description="Object to merge (use this OR ops)")
      ops: list[Operation] | None = Field(None, description="Typed operations (use this OR mutation)")
      
      @model_validator(mode="after")
      def validate_xor(self):
          if self.mutation and self.ops:
              raise ValueError("Provide mutation OR ops, not both")
          if not self.mutation and not self.ops:
              raise ValueError("Must provide mutation OR ops")
          return self
  
  @mcp.tool("orders.mutate_full")
  async def mutate_full(params: OrderMutationParams) -> Result:
      """
      Safely mutate order with automatic conflict resolution.
      Uses fetch → mutate → upload pattern with retry.
      """
  ```
- [ ] Write tests: `tests/test_mutate_full.py`
  - Mutation with deep merge
  - Mutation with typed ops
  - Concurrent mutation retry (mock timestamp changes)
  - Cache invalidation

#### 3.4 Convenience Mutation Wrappers
- [ ] Implement `routers/orders.py` additions:
  ```python
  @mcp.tool("orders.move_folder")
  async def move_folder(
      order_ids: list[str],
      destination_folder_id: str | None = None,
      destination_folder_name: str | None = None,
      store_name: str | None = None
  ) -> Result:
      """Move order(s) to folder. Uses OrderDesk batch endpoint."""
  
  @mcp.tool("orders.add_items")
  async def add_items(
      order_id: str,
      items: list[OrderItem],
      store_name: str | None = None
  ) -> Result:
      """Add items to order. Uses orders.mutate_full internally."""
  
  @mcp.tool("orders.update_address")
  async def update_address(
      order_id: str,
      address_type: Literal["shipping", "billing"],
      address: Address,
      store_name: str | None = None
  ) -> Result:
      """Update order address. Uses orders.mutate_full internally."""
  
  @mcp.tool("orders.create_history")
  async def create_history(
      order_id: str,
      message: str,
      store_name: str | None = None
  ) -> Result:
      """Add history note to order"""
  ```
- [ ] Write tests: `tests/test_order_convenience.py`
  - Move single order
  - Move multiple orders (batch)
  - Add items
  - Update address
  - Create history note

### Exit Criteria

✅ **Must Pass:**
1. `orders.mutate_full` functional with fetch → mutate → upload
2. Concurrency retry proven (test with simulated conflicts)
3. Convenience wrappers (`move_folder`, `add_items`, `update_address`) functional
4. No partial update tools exposed (verified by code review)
5. Cache invalidated on all writes
6. Test coverage > 80% for mutation logic
7. Integration test: create → mutate → verify → delete
8. Example requests in `/examples/orders_mutate_full.json`

✅ **Validation:**
```bash
# Unit tests
pytest tests/test_mutation_engine.py tests/test_mutate_full.py -v

# Concurrency retry test (simulated)
pytest tests/test_mutation_retry.py -v

# Integration test (if env vars set)
pytest tests/integration/test_orders_mutate.py -v

# Verify no partial updates
grep -r "PATCH" mcp_server/routers/ && echo "FAIL: Partial update found!" || echo "PASS"
```

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Concurrency conflicts frequent in production | High | Bounded retry (5 attempts), exponential backoff, surface clear error |
| Deep merge bugs (overwriting unintended fields) | High | Comprehensive merge tests, document mutation semantics clearly |
| OrderDesk batch endpoint quirks | Medium | Test move_folder separately, handle per-order errors in batch |
| Cache invalidation incomplete | Medium | Test all write paths, use pattern-based deletion |

---

## Phase 4: Ancillary Resources

**Goal:** Mirror remaining OrderDesk endpoints with full parameter exposure.

### Tasks

#### 4.1 Order Items Tools
- [ ] Implement `routers/order_items.py`:
  ```python
  @mcp.tool("order_items.list")
  async def list_items(order_id: str, store_name: str | None = None) -> Result:
      """Get all items for an order"""
  
  @mcp.tool("order_items.get")
  async def get_item(order_id: str, item_id: str, store_name: str | None = None) -> Result:
      """Get single order item"""
  
  @mcp.tool("order_items.create")
  async def create_item(order_id: str, item: OrderItem, store_name: str | None = None) -> Result:
      """Add item to order"""
  
  @mcp.tool("order_items.update")
  async def update_item(order_id: str, item_id: str, item: OrderItem, store_name: str | None = None) -> Result:
      """Update order item"""
  
  @mcp.tool("order_items.delete")
  async def delete_item(order_id: str, item_id: str, store_name: str | None = None) -> Result:
      """Remove item from order"""
  ```
- [ ] Write tests: `tests/test_order_items.py`

#### 4.2 Shipments Tools
- [ ] Implement `routers/shipments.py`:
  ```python
  class Shipment(BaseModel):
      # All shipment fields per OD docs
      pass
  
  @mcp.tool("shipments.list")
  async def list_shipments(order_id: str, store_name: str | None = None) -> Result:
      """Get all shipments for an order"""
  
  @mcp.tool("shipments.get")
  async def get_shipment(order_id: str, shipment_id: str, store_name: str | None = None) -> Result:
      """Get single shipment"""
  
  @mcp.tool("shipments.create")
  async def create_shipment(order_id: str, shipment: Shipment, store_name: str | None = None) -> Result:
      """Add shipment to order"""
  
  @mcp.tool("shipments.update")
  async def update_shipment(order_id: str, shipment_id: str, shipment: Shipment, store_name: str | None = None) -> Result:
      """Update shipment"""
  
  @mcp.tool("shipments.delete")
  async def delete_shipment(order_id: str, shipment_id: str, store_name: str | None = None) -> Result:
      """Remove shipment"""
  
  @mcp.tool("shipments.batch_create")
  async def batch_create_shipments(shipments: list[Shipment], store_name: str | None = None) -> Result:
      """Create multiple shipments (batch endpoint)"""
  ```
- [ ] Write tests: `tests/test_shipments.py`

#### 4.3 Products/Inventory Tools
- [ ] Implement `routers/products.py`:
  ```python
  class InventoryItem(BaseModel):
      # All inventory item fields per OD docs
      pass
  
  class ProductsListParams(BaseModel):
      store_name: str | None = None
      code: str | None = Field(None, description="Filter by SKU/code")
      search: str | None = Field(None, description="Search in name, code, metadata")
      limit: int = Field(50, ge=1, le=250)
      page: int = Field(1, ge=1)
      # Add ALL other documented OD params
  
  @mcp.tool("products.list")
  async def list_products(params: ProductsListParams) -> Result:
      """List inventory items with full pagination"""
  
  @mcp.tool("products.get")
  async def get_product(id: str, store_name: str | None = None) -> Result:
      """Get single inventory item"""
  
  @mcp.tool("products.create")
  async def create_product(item: InventoryItem, store_name: str | None = None) -> Result:
      """Create inventory item"""
  
  @mcp.tool("products.update")
  async def update_product(id: str, item: InventoryItem, store_name: str | None = None) -> Result:
      """Update inventory item"""
  
  @mcp.tool("products.delete")
  async def delete_product(id: str, store_name: str | None = None) -> Result:
      """Delete inventory item"""
  
  @mcp.tool("products.batch_update")
  async def batch_update_products(items: list[InventoryItem], store_name: str | None = None) -> Result:
      """Update multiple inventory items (batch endpoint)"""
  ```
- [ ] Write tests: `tests/test_products.py`

#### 4.4 Folders Tool (Read-Only)
- [ ] Already implemented via `store.get_settings` in Phase 2
- [ ] Optionally add convenience wrapper:
  ```python
  @mcp.tool("folders.list")
  async def list_folders(store_name: str | None = None) -> Result:
      """Get folder structure (convenience wrapper around store.get_settings)"""
  ```

#### 4.5 Additional Resources (As Needed)
- [ ] Customers (if OrderDesk supports customer endpoints)
- [ ] Rules (if automation rules are exposed via API)
- [ ] Reports (if reporting endpoints are available)

**Note:** Only implement resources that have documented OrderDesk API endpoints. Do not invent.

### Exit Criteria

✅ **Must Pass:**
1. All documented OrderDesk resources have corresponding tools
2. All tools expose full parameter sets (no hidden defaults)
3. Pagination consistent across all list endpoints
4. Caching implemented for read operations
5. Cache invalidation on writes
6. Test coverage > 75% for new tools
7. Example requests in `/examples` for each resource type

✅ **Validation:**
```bash
# Unit tests
pytest tests/test_order_items.py tests/test_shipments.py tests/test_products.py -v

# Verify parameter completeness (manual review)
# Compare tool schemas against OrderDesk API docs

# Integration test (if env vars set)
pytest tests/integration/test_resources.py -v
```

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| API docs incomplete or outdated | Medium | Test against live API, surface errors clearly |
| Resource-specific quirks | Medium | Per-resource tests, document edge cases |
| Test coverage sprawl | Low | Shared fixtures, parameterized tests |

---

## Phase 5: Optional HTTP/SSE/WSS Adapter

**Goal:** Add optional HTTP transport for web clients, health checks, and webhooks.

**Note:** This phase is OPTIONAL and can be skipped if only stdio transport is needed.

### Tasks

#### 5.1 FastAPI Adapter
- [ ] Add `mcp_server/http_adapter.py`:
  ```python
  app = FastAPI(title="OrderDesk MCP Server HTTP Adapter")
  
  @app.get("/health")
  async def health():
      return {"status": "ok", "version": __version__}
  
  @app.get("/metrics")
  async def metrics():
      # Prometheus-format metrics
      pass
  ```

#### 5.2 SSE Transport (Server-Sent Events)
- [ ] Implement SSE endpoint for MCP:
  ```python
  @app.get("/mcp/sse")
  async def mcp_sse(authorization: str = Header(None)):
      # Authenticate with master key
      # Stream MCP messages via SSE
      pass
  ```

#### 5.3 WebSocket Transport (Optional)
- [ ] Implement WebSocket endpoint for MCP:
  ```python
  @app.websocket("/mcp/ws")
  async def mcp_ws(websocket: WebSocket):
      # Authenticate
      # Bidirectional MCP messages
      pass
  ```

#### 5.4 Webhook Ingestion
- [ ] Implement webhook receiver:
  ```python
  @app.post("/webhooks/orderdesk")
  async def receive_webhook(
      payload: dict,
      signature: str = Header(None, alias="X-OrderDesk-Signature")
  ):
      # Verify signature (if WEBHOOK_SECRET set)
      # Process webhook
      # Trigger cache invalidation if needed
      pass
  ```

#### 5.5 Proxy Header Handling
- [ ] Implement `utils/proxy.py`:
  ```python
  def get_client_ip(request: Request, trust_proxy: bool = False) -> str:
      if trust_proxy:
          # Check X-Forwarded-For, CF-Connecting-IP, etc.
          pass
      return request.client.host
  ```
- [ ] Add middleware to inject client IP into logs
- [ ] Write tests: `tests/test_proxy.py`

#### 5.6 Documentation
- [ ] Update README with HTTP transport instructions
- [ ] Add Postman/Thunder Client collection (optional)

### Exit Criteria

✅ **Must Pass (if implementing HTTP):**
1. stdio transport still works (primary path)
2. `GET /health` returns 200 OK
3. SSE transport functional (if implemented)
4. WebSocket transport functional (if implemented)
5. Proxy headers parsed correctly when `TRUST_PROXY=true`
6. Webhook signature validation works (if `WEBHOOK_SECRET` set)
7. Test coverage > 70% for HTTP adapter

✅ **Validation:**
```bash
# stdio still primary
echo '{"method":"tools/list"}' | python -m mcp_server.main

# HTTP health check
curl http://localhost:8080/health

# Proxy headers
curl -H "X-Forwarded-For: 1.2.3.4" http://localhost:8080/health
grep "client_ip=1.2.3.4" logs/app.log
```

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| HTTP overhead complicates deployment | Medium | Keep HTTP adapter thin, optional |
| Proxy header parsing security | High | Only parse when TRUST_PROXY=true, validate IPs |
| Webhook replay attacks | Medium | Implement signature validation, request deduplication |

---

## Phase 6: Docs & Examples

**Goal:** Comprehensive documentation enabling first-run success without maintainer support.

### Tasks

#### 6.1 README.md (User-Facing)
- [ ] Quickstart (<5 minutes to running server):
  - Installation (Docker or pip)
  - Generate `MCP_KMS_KEY`
  - Run server
  - Test with first tool call
- [ ] Tenancy model explanation:
  - Master key concept
  - Store registration
  - Session context
- [ ] Pagination control examples:
  - Default behavior
  - Custom limits
  - Why explicit control matters
- [ ] Full-order mutations explanation:
  - Why fetch → mutate → upload
  - Concurrency handling
  - When to use convenience wrappers
- [ ] Cloudflare Tunnel setup:
  - Docker + tunnel configuration
  - Proxy headers
- [ ] Troubleshooting:
  - Common errors and fixes
  - Log locations
  - Debug mode

#### 6.2 docs/SETUP_GUIDE.md
- [ ] Detailed deployment instructions:
  - Local development
  - Docker Compose
  - Railway / Render / Fly.io
  - Cloudflare Tunnel
  - Kubernetes (advanced)
- [ ] Environment variable reference (all vars documented)
- [ ] Security best practices:
  - Master key rotation
  - API key storage
  - Log redaction verification
- [ ] Monitoring and observability:
  - Log structure
  - Metrics endpoint
  - Health checks

#### 6.3 docs/MCP_TOOLS_REFERENCE.md
- [ ] Complete tool catalog:
  - Tool name
  - Description (maps to which OD endpoint)
  - Parameters (with types, required, defaults, constraints)
  - Example request
  - Example response
  - Error cases
- [ ] Organized by category:
  - Tenant & Store Management
  - Orders (read, write, mutate)
  - Order Items
  - Shipments
  - Products/Inventory
  - Store Settings

#### 6.4 docs/operations.md
- [ ] Full-order update contract:
  - Why full updates only
  - Mutation semantics (deep merge)
  - Typed operations
- [ ] Retry and concurrency:
  - Conflict detection
  - Retry strategy
  - Max retries
- [ ] Caching:
  - What's cached
  - TTLs per resource
  - Invalidation strategy
  - Redis vs memory
- [ ] Rate limiting:
  - Per-tenant limits
  - OrderDesk API limits
  - Handling 429 responses

#### 6.5 .env.example
- [ ] All environment variables with:
  - Description
  - Required vs optional
  - Default value
  - Example value
  - Security notes

#### 6.6 Examples Directory
- [ ] Create `/examples` with JSON files:
  - `tenant_use_master_key.json`
  - `stores_register.json`
  - `stores_list.json`
  - `stores_use_store.json`
  - `orders_list.json`
  - `orders_get.json`
  - `orders_create.json`
  - `orders_mutate_full.json`
  - `orders_move_folder.json`
  - `products_list.json`
  - `shipments_create.json`
- [ ] Each file includes:
  - Request parameters
  - Expected response (or sample)
  - Notes on usage

#### 6.7 Thunder Client / Postman Collection (Optional)
- [ ] If HTTP transport implemented:
  - Export collection with all tools
  - Include environment variables template

### Exit Criteria

✅ **Must Pass:**
1. README enables first-run success (<5 min from clone to working)
2. SETUP_GUIDE covers all deployment scenarios
3. MCP_TOOLS_REFERENCE documents all tools with examples
4. operations.md explains mutation contract clearly
5. .env.example includes all variables with safe defaults
6. `/examples` directory has valid, copy-pasteable requests
7. Docs reviewed by someone unfamiliar with project (user testing)

✅ **Validation:**
```bash
# First-run test (fresh environment)
git clone <repo>
cd orderdesk-mcp-server
# Follow README quickstart
# Should be running in <5 minutes

# Doc completeness check
# Compare tool list in docs vs implemented tools
diff <(grep "@mcp.tool" -r mcp_server/routers | wc -l) \
     <(grep "^###" docs/MCP_TOOLS_REFERENCE.md | wc -l)
```

### Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Docs out of sync with code | High | Generate docs from code where possible, CI checks |
| Examples break with API changes | Medium | Integration tests use same examples |
| Overwhelming detail | Low | Layered docs: README (quick), SETUP (detailed), REFERENCE (exhaustive) |

---

## Cross-Cutting Concerns (Apply to All Phases)

### 1. Schema Quality Checklist
Every tool MUST have:
- [ ] JSON Schema with `type`, `description`, `required`, `default` (where applicable)
- [ ] At least one example in schema or separate file
- [ ] All documented OrderDesk parameters exposed (no hiding)
- [ ] Validation that rejects unknown parameters
- [ ] Helpful error messages with examples when validation fails

### 2. Security Checklist
Every phase MUST verify:
- [ ] Secrets encrypted at rest (API keys)
- [ ] No secrets in logs (redaction filter applied)
- [ ] No secrets in error messages
- [ ] Input validation prevents injection
- [ ] Rate limiting enforced per tenant
- [ ] Audit logs (if implemented) redact sensitive fields

### 3. Observability Checklist
Every tool call MUST log:
- [ ] Correlation ID (UUID)
- [ ] Tenant ID (if authenticated)
- [ ] Store ID (if applicable)
- [ ] Tool name
- [ ] Duration (ms)
- [ ] Status (success/error)
- [ ] Error code and message (if error)

Log format (JSON):
```json
{
  "timestamp": "2025-10-17T12:34:56.789Z",
  "level": "INFO",
  "correlation_id": "abc-123",
  "tenant_id": "tenant-456",
  "store_id": "store-789",
  "tool_name": "orders.list",
  "duration_ms": 234,
  "status": "success",
  "cache_hit": false
}
```

### 4. CI/CD Checklist
Every commit MUST pass:
- [ ] `ruff check .` (linting)
- [ ] `black --check .` (formatting)
- [ ] `mypy mcp_server/` (type checking)
- [ ] `pytest tests/ --cov=mcp_server --cov-report=term-missing` (tests with coverage)
- [ ] `docker build -t orderdesk-mcp-server .` (Docker build)

Coverage targets:
- Overall: > 75%
- Critical paths (auth, mutation): > 90%

---

## Overall Acceptance Criteria

### Functional Requirements
✅ All documented OrderDesk API endpoints mapped to MCP tools  
✅ Master key tenancy + store registration operational  
✅ Session context (tenant + active store) working  
✅ Store lookup by name resolves credentials  
✅ Full-order mutations use fetch → mutate → upload pattern  
✅ Concurrency conflicts handled with bounded retry  
✅ LLM can control pagination explicitly (limit, page, etc.)  
✅ No invented endpoints or parameters  
✅ Cache invalidation on writes

### Non-Functional Requirements
✅ CI/CD pipeline green (lint, type, test, build)  
✅ Test coverage > 75% overall, > 90% for critical paths  
✅ Structured logging with correlation IDs  
✅ Secrets never in logs (verified by automated test)  
✅ Docker container builds and runs  
✅ Documentation complete and actionable  
✅ First-run success < 5 minutes (README test)

### Quality Gates
✅ Zero linter errors (`ruff check .`)  
✅ Zero type errors (`mypy --strict`)  
✅ All tests pass (`pytest tests/`)  
✅ Docker build succeeds  
✅ Integration tests pass (if env vars set)  
✅ No hardcoded secrets in code or config  
✅ Conventional commit messages enforced

---

## Risk Register

### Critical Risks

| Risk | Phase | Impact | Probability | Mitigation | Owner |
|------|-------|--------|-------------|------------|-------|
| Crypto implementation bug leaks secrets | P1 | Critical | Low | Use battle-tested libraries, comprehensive tests, code review | Dev |
| OrderDesk API undocumented behavior | P2-4 | High | Medium | Test against live API, surface errors clearly, document quirks | Dev |
| Concurrency conflicts frequent | P3 | High | Medium | Bounded retry with backoff, clear error messages | Dev |
| Rate limits during testing | P2-4 | Medium | High | Smart retry, integration test guards, mock responses | Dev |
| Session state bugs across requests | P1 | High | Medium | Use async context vars, comprehensive tests, clear lifecycle | Dev |
| Docs out of sync with code | P6 | Medium | High | Generate from code where possible, CI doc checks | Dev |

### Medium Risks

| Risk | Phase | Impact | Probability | Mitigation | Owner |
|------|-------|--------|-------------|------------|-------|
| Cache invalidation incomplete | P2-3 | Medium | Medium | Test all write paths, pattern-based deletion | Dev |
| Deep merge overwrites unintended fields | P3 | Medium | Medium | Comprehensive merge tests, document semantics | Dev |
| Pagination params differ per resource | P2,P4 | Medium | Medium | Read docs carefully, per-resource tests | Dev |
| HTTP adapter adds deployment complexity | P5 | Low | Medium | Keep adapter thin and optional | Dev |

---

## Success Metrics (Post-Launch)

After completing all phases, measure:

1. **Reliability:**
   - Uptime > 99%
   - Error rate < 5%
   - p95 latency < 500ms (cached reads)

2. **Security:**
   - Zero secret leakage incidents
   - Zero credential compromises
   - Automated secret scanning passes

3. **Usability:**
   - First-run success rate > 90% (new users)
   - Documentation clarity rating > 4/5
   - Support tickets < 5/month

4. **Performance:**
   - Cache hit rate > 80%
   - Rate limit exhaustion < 1% of requests
   - Concurrency retry success > 95%

---

## References

### External
- **OrderDesk API:** https://apidocs.orderdesk.com/
- **MCP Protocol:** https://modelcontextprotocol.io/
- **HKDF (RFC 5869):** https://tools.ietf.org/html/rfc5869
- **AES-GCM:** https://csrc.nist.gov/publications/detail/sp/800-38d/final

### Internal
- [`speckit.constitution`](./speckit.constitution)
- [`speckit.specify`](./speckit.specify)
- [`README.md`](./README.md)
- [`docs/SETUP_GUIDE.md`](./docs/SETUP_GUIDE.md)
- [`docs/MCP_TOOLS_REFERENCE.md`](./docs/MCP_TOOLS_REFERENCE.md)
- [`docs/operations.md`](./docs/operations.md)

---

## Changelog

### v1.0.0 (2025-10-17)
- Initial implementation plan
- 7 phases defined with exit criteria
- Cross-cutting concerns documented
- Risk register established

---

**END OF IMPLEMENTATION PLAN**

