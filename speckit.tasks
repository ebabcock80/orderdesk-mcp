# Task Breakdown: OrderDesk MCP Server

**Version:** 1.0  
**Status:** Active Task List  
**Last Updated:** October 17, 2025  
**Format:** [ID] Title — Detail (Assignee?, Estimate)

**Companion Documents:**
- [`speckit.constitution`](./speckit.constitution) - Design principles
- [`speckit.specify`](./speckit.specify) - Technical specification  
- [`speckit.plan`](./speckit.plan) - Implementation plan with phases

---

## Task Format

```
[CATEGORY-NUMBER] Title — Description (Assignee, Time Estimate)
```

**Categories:**
- **BOOT** - Bootstrap & Infrastructure
- **SEC** - Security & Cryptography
- **DB** - Database & Storage
- **AUTH** - Authentication & Authorization
- **CTX** - Session Context Management
- **STORE** - Store Management Tools
- **HTTP** - HTTP Client & OrderDesk API
- **CACHE** - Caching Layer
- **ORD-READ** - Orders Read Operations
- **ORD-WRITE** - Orders Write Operations
- **ORD-MUT** - Orders Mutation Operations
- **ITEMS** - Order Items Tools
- **SHIP** - Shipments Tools
- **PROD** - Products/Inventory Tools
- **ANC** - Ancillary Resources (folders, customers, etc.)
- **OBS** - Observability (logging, metrics)
- **HTTP-OPT** - Optional HTTP/SSE/WSS Transport
- **DOC** - Documentation
- **TEST** - Testing
- **CI** - CI/CD Pipeline

---

## Universal Acceptance Criteria (All Tasks)

Every task MUST satisfy:
- ✅ Schema includes `required` fields and examples
- ✅ Unit tests cover: happy path, validation errors, edge cases
- ✅ No invented parameters; all OrderDesk API options present or documented as unsupported
- ✅ Secrets redacted in logs (if applicable)
- ✅ Type hints on all functions
- ✅ Docstrings with parameter descriptions
- ✅ Code passes: `ruff check`, `black --check`, `mypy --strict`

---

## Phase 0: Bootstrap & CI

### Infrastructure Setup

**[BOOT-01] Repository Structure** — Create directory layout per constitution (2h)
- Create all directories: `mcp_server/{auth,models,routers,services,utils}`, `tests/`, `docs/`, `examples/`
- Add `__init__.py` to all packages
- Create `.gitignore` (exclude `data/`, `*.db`, `.env`, `__pycache__/`, `venv/`)
- Acceptance: Directory structure matches constitution, git repo initialized

**[BOOT-02] pyproject.toml** — Configure project dependencies and metadata (2h)
- Core deps: `mcp>=1.0.0`, `httpx>=0.27.0`, `pydantic>=2.0`, `sqlalchemy>=2.0`, `cryptography>=42.0`
- Dev deps: `pytest>=8.0`, `pytest-asyncio>=0.23`, `pytest-cov>=4.1`, `ruff>=0.3`, `mypy>=1.9`, `black>=24.0`
- Configure `[tool.ruff]`, `[tool.mypy]`, `[tool.pytest]`
- Set version: `0.1.0-alpha`
- Acceptance: `pip install -e .` works, all deps resolve

**[BOOT-03] Docker Configuration** — Dockerfile with multi-stage build (3h)
- Stage 1: Builder (install deps, compile if needed)
- Stage 2: Runtime (slim Python 3.11+, copy only runtime files)
- Non-root user (`appuser`)
- Volume mount point: `/app/data`
- Health check: `CMD python -c "import sys; sys.exit(0)"`
- Acceptance: `docker build` succeeds, image < 200MB

**[BOOT-04] docker-compose.yml** — Compose file with app + optional redis (2h)
- App service with env vars, volume mounts, health check
- Redis service (commented out by default)
- Network configuration
- Acceptance: `docker-compose up` starts successfully

**[BOOT-05] .env.example** — Template with all environment variables (2h)
- All required vars: `MCP_KMS_KEY`
- All optional vars with defaults and descriptions
- Security notes for sensitive vars
- Example values (safe, non-production)
- Acceptance: Every env var in code has corresponding entry

### Core Configuration

**[SEC-01] Configuration Loader** — Load and validate environment variables (2h)
- Implement `config.py` with Pydantic `BaseSettings`
- Required fields: `MCP_KMS_KEY` (min 32 bytes base64)
- Optional fields with sensible defaults
- Validation errors with helpful messages
- Acceptance: Missing required var fails fast, invalid format caught

**[OBS-01] Structured Logging** — JSON logging with correlation IDs (2h)
- Implement `utils/logging.py`
- JSON formatter with standard fields: `timestamp`, `level`, `message`, `correlation_id`, `tenant_id`, `store_id`
- Secret redaction filter (keys: `master_key`, `api_key`, `password`, `token`, `secret`)
- Configurable log level via `LOG_LEVEL` env var
- Acceptance: Logs are valid JSON, secrets never appear, correlation ID in every log line

**[BOOT-06] Common Types & Errors** — Base models and exceptions (2h)
- Implement `models/common.py`:
  - `MCPError(code, message, details)`
  - `Result[T](status, data, error)`
  - Domain exceptions: `OrderDeskError`, `ValidationError`, `AuthError`, `ConflictError`, `RateLimitError`
- Error to MCP error envelope converter
- Acceptance: All exceptions inherit from `MCPError`, envelope format matches MCP spec

**[BOOT-07] Basic MCP Server** — Stdio transport initialization (4h)
- Implement `mcp_server.py`:
  - stdio transport setup
  - Tool registration decorator
  - Error handling and formatting
  - Session management
- Implement `main.py`:
  - Entry point
  - Graceful shutdown (SIGINT, SIGTERM)
  - Command-line args (if any)
- Acceptance: `python -m mcp_server.main` starts, accepts JSON-RPC via stdin

**[BOOT-08] Health Check** — Basic health endpoint (if HTTP enabled) (1h)
- Implement `routers/health.py`:
  - `GET /health` → `{"status": "ok", "version": "0.1.0"}`
- Acceptance: curl returns 200 OK with JSON

### CI/CD Pipeline

**[CI-01] GitHub Actions Workflow** — Automated checks and build (3h)
- Create `.github/workflows/ci.yml`:
  - Job 1: Lint (ruff check)
  - Job 2: Format check (black --check)
  - Job 3: Type check (mypy mcp_server/)
  - Job 4: Test (pytest with coverage)
  - Job 5: Docker build
- Run on: push, pull_request to main
- Require checks to pass for merge
- Acceptance: Push triggers workflow, all jobs pass

**[CI-02] Pre-commit Hooks** — Local validation before commit (optional) (1h)
- Configure `.pre-commit-config.yaml`:
  - ruff
  - black
  - mypy
  - pytest (optional)
- Acceptance: `pre-commit run --all-files` passes

---

## Phase 1: Auth, Storage, Session Context

### Cryptography & Security

**[SEC-02] HKDF Key Derivation** — Derive per-tenant encryption keys (2h)
- Implement `auth/crypto.py::derive_tenant_key()`:
  - HKDF-SHA256
  - IKM: `MCP_KMS_KEY` from env
  - Salt: random per tenant, stored in DB
  - Info: `b"orderdesk-mcp-tenant-{salt}"`
  - Output: 32 bytes (AES-256 key)
- Acceptance: Same inputs → same output, different salt → different output

**[SEC-03] AES-256-GCM Encryption** — Encrypt API keys at rest (3h)
- Implement `auth/crypto.py::encrypt_api_key()`:
  - AES-256-GCM mode
  - Random 12-byte nonce per encryption
  - Return: `(ciphertext_b64, tag_b64, nonce_b64)`
- Implement `auth/crypto.py::decrypt_api_key()`:
  - Verify GCM tag
  - Raise `AuthError` on tampered data
- Acceptance: Roundtrip encrypt→decrypt works, wrong key fails, tampered ciphertext fails

**[SEC-04] Master Key Hashing** — Secure password hashing (2h)
- Implement `auth/crypto.py::hash_master_key()`:
  - Use bcrypt or argon2
  - Random salt per tenant
  - Return: `(hash, salt)`
- Implement `auth/crypto.py::verify_master_key()`:
  - Constant-time comparison
- Acceptance: Same key verifies, wrong key fails, timing safe

**[SEC-05] Crypto Unit Tests** — Comprehensive crypto tests (2h)
- Write `tests/test_crypto.py`:
  - HKDF deterministic
  - Encrypt/decrypt roundtrip
  - Wrong key fails decryption
  - Tag tampering caught
  - Hash/verify roundtrip
- Acceptance: 100% coverage of crypto functions

### Database & Storage

**[DB-01] Database Models** — SQLAlchemy models for tenants and stores (3h)
- Implement `models/database.py`:
  ```python
  class Tenant(Base):
      id: str  # UUID primary key
      master_key_hash: str
      salt: str  # For HKDF
      created_at: datetime
      updated_at: datetime
  
  class Store(Base):
      id: str  # UUID primary key
      tenant_id: str  # Foreign key → tenants.id
      store_id: str  # OrderDesk store ID
      store_name: str  # Friendly name
      label: str | None
      api_key_ciphertext: str  # Base64 encrypted
      api_key_tag: str  # GCM tag
      api_key_nonce: str  # GCM nonce
      created_at: datetime
      updated_at: datetime
  ```
- Constraints: UNIQUE(tenant_id, store_name), UNIQUE(tenant_id, store_id)
- Acceptance: Models create tables, constraints enforced

**[DB-02] Database Initialization** — Setup script and engine (2h)
- Implement `models/database.py::init_db()`:
  - Create engine from `DATABASE_URL` env var
  - Create all tables
  - Setup connection pooling
- Create `data/` directory for SQLite file
- Acceptance: First run creates schema, subsequent runs reuse

**[DB-03] Database Migrations** — Optional Alembic setup (3h, optional)
- Initialize Alembic
- Create initial migration
- Migration for adding audit_log table (future)
- Acceptance: `alembic upgrade head` creates schema

**[DB-04] Database Tests** — Schema and constraint validation (2h)
- Write `tests/test_database.py`:
  - Create tenant
  - Create store
  - Unique constraint violations
  - Foreign key cascade (delete tenant → delete stores)
- Acceptance: All constraints enforced, no leakage

### Authentication & Tenant Management

**[AUTH-01] Tenant Service** — Core tenant operations (3h)
- Implement `services/tenant.py`:
  ```python
  class TenantService:
      async def authenticate(master_key: str) -> Tenant | None
      async def create_tenant(master_key: str) -> Tenant
      async def get_tenant_by_id(tenant_id: str) -> Tenant | None
  ```
- Auto-provision toggle: if `AUTO_PROVISION_TENANT=true`, create tenant on first auth
- Acceptance: Auth works, auto-provision respects flag

**[AUTH-02] Tenant Unit Tests** — Test authentication flows (2h)
- Write `tests/test_tenant.py`:
  - Successful auth with correct key
  - Failed auth with wrong key
  - Auto-provision creates tenant
  - Auto-provision disabled rejects unknown key
- Acceptance: 100% coverage of tenant service

**[AUTH-03] Bearer Token Parsing** — Extract master key from session (2h)
- Implement `auth/middleware.py::extract_bearer_token()`:
  - Parse `Authorization: Bearer <master_key>` header (if HTTP)
  - Parse from MCP session context (if stdio)
- Acceptance: Token extracted correctly, missing token raises `AuthError`

### Store Management

**[STORE-01] Store Service** — Core store operations (4h)
- Implement `services/store.py`:
  ```python
  class StoreService:
      async def register_store(tenant_id, store_id, api_key, store_name?, label?) -> Store
      async def list_stores(tenant_id) -> list[Store]
      async def get_store(tenant_id, store_id) -> Store | None
      async def get_store_by_name(tenant_id, store_name) -> Store | None
      async def resolve_store(tenant_id, identifier) -> Store | None
      async def delete_store(tenant_id, store_id) -> bool
      async def get_decrypted_credentials(store, tenant_key) -> tuple[str, str]
  ```
- On register: encrypt API key, store ciphertext/tag/nonce
- On resolve: try store_id first, fallback to store_name
- Acceptance: All CRUD operations work, encryption verified

**[STORE-02] Store Unit Tests** — Test store management (3h)
- Write `tests/test_stores.py`:
  - Register store encrypts API key
  - List stores for tenant (no cross-tenant leakage)
  - Lookup by store_id
  - Lookup by store_name
  - Resolve handles both
  - Delete removes store
  - Duplicate store_name rejected
  - Duplicate store_id rejected
- Acceptance: 100% coverage of store service

### Session Context

**[CTX-01] Session Context Manager** — Maintain active tenant and store (3h)
- Implement `services/session.py`:
  ```python
  class SessionContext:
      tenant_id: str | None
      tenant_key: bytes | None
      active_store_id: str | None
      correlation_id: str
      
      def set_tenant(tenant: Tenant, master_key: str)
      def set_active_store(store_id: str)
      def get_active_store() -> Store | None
      def clear()
  ```
- Use async context vars (or thread-local for sync)
- Generate correlation ID on init (UUID4)
- Acceptance: Context persists across async tasks, isolated per session

**[CTX-02] Session Unit Tests** — Test context lifecycle (2h)
- Write `tests/test_session.py`:
  - Context scoped per session
  - Tenant key derived on set_tenant
  - Active store persists across tool calls
  - Clear resets context
  - Isolation between concurrent sessions
- Acceptance: 100% coverage of session context

### Rate Limiting

**[AUTH-04] Rate Limiter** — Per-tenant rate limiting (3h)
- Implement `services/rate_limit.py`:
  ```python
  class RateLimiter:
      def __init__(rpm: int = 120)
      async def check(tenant_id: str) -> bool
      async def consume(tenant_id: str) -> bool
      async def reset(tenant_id: str)
  ```
- Sliding window algorithm
- In-memory backend (default), optional Redis
- Acceptance: Allows under limit, blocks over limit, sliding window behavior

**[AUTH-05] Rate Limiter Tests** — Validate rate limiting (2h)
- Write `tests/test_rate_limit.py`:
  - Allows requests under RPM
  - Blocks requests over RPM
  - Sliding window resets correctly
  - Per-tenant isolation
- Acceptance: 100% coverage, edge cases handled

### MCP Tools: Tenant & Store Management

**[STORE-03] tenant.use_master_key Tool** — Authenticate tenant (2h)
- Implement `routers/stores.py::use_master_key()`:
  - Input: `master_key: str`
  - Validate master key against DB
  - Set session context
  - Return: `{status, tenant_id, stores_count, message}`
- Add JSON schema with example
- Acceptance: Tool registered, auth works, session set

**[STORE-04] stores.register Tool** — Register OrderDesk store (2h)
- Implement `routers/stores.py::register_store()`:
  - Inputs: `store_id`, `api_key`, `store_name?`, `label?`
  - Encrypt API key
  - Store in DB
  - Return: `{status, store_id, store_name, message}`
- Add JSON schema with example
- Acceptance: Store registered, credentials encrypted

**[STORE-05] stores.list Tool** — List registered stores (1h)
- Implement `routers/stores.py::list_stores()`:
  - No input (uses session context)
  - Return: `{status, stores: [{id, store_id, store_name, label}]}`
  - Never return decrypted API keys
- Acceptance: Lists only current tenant's stores

**[STORE-06] stores.delete Tool** — Remove store registration (1h)
- Implement `routers/stores.py::delete_store()`:
  - Input: `store_id: str`
  - Delete from DB
  - Return: `{status, message}`
- Acceptance: Store removed, credentials wiped

**[STORE-07] stores.use_store Tool** — Set active store (2h)
- Implement `routers/stores.py::use_store()`:
  - Input: `identifier: str` (store_id or store_name)
  - Resolve via `StoreService.resolve_store()`
  - Set session context
  - Return: `{status, store_id, store_name, message}`
- Acceptance: Active store persists, ambiguous name handled

**[STORE-08] stores.resolve Tool** — Debug tool to resolve store (1h)
- Implement `routers/stores.py::resolve_store()`:
  - Input: `identifier: str`
  - Return: `{status, store_id, store_name, label}`
  - Debug/testing only
- Acceptance: Resolves by ID or name

**[STORE-09] Store Tools Integration Test** — Full workflow test (2h)
- Write `tests/test_store_tools.py`:
  - Authenticate with `tenant.use_master_key`
  - Register store with `stores.register`
  - List stores with `stores.list`
  - Set active store with `stores.use_store`
  - Delete store with `stores.delete`
- Acceptance: Full flow works end-to-end

---

## Phase 2: Order Read Path & Pagination

### HTTP Client & OrderDesk API

**[HTTP-01] OrderDesk HTTP Client** — Async httpx client with retries (4h)
- Implement `services/orderdesk.py`:
  ```python
  class OrderDeskClient:
      def __init__(store_id: str, api_key: str)
      async def get(endpoint: str, params: dict | None) -> dict
      async def post(endpoint: str, data: dict) -> dict
      async def put(endpoint: str, data: dict) -> dict
      async def delete(endpoint: str) -> dict
  ```
- Configure httpx: 30s timeout, connection pooling
- Headers: `ORDERDESK-STORE-ID`, `ORDERDESK-API-KEY`
- Base URL: `https://app.orderdesk.me/api/v2`
- Acceptance: Client makes requests, headers set correctly

**[HTTP-02] Retry Logic** — Exponential backoff for 429/5xx (3h)
- Implement `services/orderdesk.py::_retry_with_backoff()`:
  - Retry on 429: respect `X-Retry-After` header
  - Retry on 5xx: exponential backoff (1s, 2s, 4s) + jitter
  - Max retries: 3 (configurable)
  - Log each retry attempt
- Acceptance: Retries work, backoff delays correct, max retries honored

**[HTTP-03] Rate Limit Header Parsing** — Parse OrderDesk rate limit headers (2h)
- Implement `services/orderdesk.py::_parse_rate_limit_headers()`:
  - Extract `X-Tokens-Remaining`
  - Extract `X-Retry-After`
  - Log warnings when tokens low (<5)
  - Raise `RateLimitError` on 429 after retries exhausted
- Acceptance: Headers parsed, warnings logged

**[HTTP-04] OrderDesk Client Tests** — Test HTTP client (3h)
- Write `tests/test_orderdesk_client.py`:
  - Successful GET request (mock response)
  - Retry on 429 with backoff
  - Retry on 5xx with backoff
  - Headers added correctly
  - Timeout handling
  - Rate limit headers parsed
- Use `httpx_mock` or similar
- Acceptance: 100% coverage of client logic

### OrderDesk Data Models

**[HTTP-05] OrderDesk Models** — Pydantic models for OD resources (4h)
- Implement `models/orderdesk.py`:
  ```python
  class Address(BaseModel): ...
  class OrderItem(BaseModel): ...
  class Order(BaseModel): ...
  class InventoryItem(BaseModel): ...
  class Shipment(BaseModel): ...
  ```
- Map ALL fields from OrderDesk API docs
- Use proper types: `datetime`, `Decimal`, `Optional`, etc.
- Acceptance: Models parse actual OD responses without errors

**[HTTP-06] Model Validation Tests** — Test models against real data (2h)
- Write `tests/test_orderdesk_models.py`:
  - Parse sample Order JSON (from OD docs)
  - Parse sample Product JSON
  - Handle missing optional fields
  - Validate required fields
- Acceptance: Models parse all documented fields

### Caching Layer

**[CACHE-01] Cache Service Interface** — Abstract cache backend (3h)
- Implement `services/cache.py`:
  ```python
  class CacheService:
      async def get(key: str) -> Any | None
      async def set(key: str, value: Any, ttl: int | None)
      async def delete(key: str)
      async def delete_pattern(pattern: str)
      def make_key(tenant_id, store_id, resource, resource_id) -> str
  ```
- Key format: `{tenant_id}:{store_id}:{resource}:{id}`
- Acceptance: Interface defined, key generation tested

**[CACHE-02] Memory Backend** — In-memory cache implementation (2h)
- Implement `services/cache.py::MemoryCache`:
  - Use `dict` with expiry tracking
  - Background task to clean expired keys
  - Thread-safe (use asyncio.Lock)
- Acceptance: Set/get/delete work, TTL expires keys

**[CACHE-03] Redis Backend** — Optional Redis implementation (3h)
- Implement `services/cache.py::RedisCache`:
  - Use `redis.asyncio`
  - Pattern delete via SCAN + DEL
  - Handle connection errors gracefully
- Acceptance: Redis backend works, fallback on connection failure

**[CACHE-04] Cache Tests** — Test cache backends (2h)
- Write `tests/test_cache.py`:
  - Memory backend: set/get/delete/expire
  - Redis backend: same tests (requires running Redis)
  - Key generation format
  - Pattern deletion
- Acceptance: 100% coverage, both backends tested

### Orders Read Operations

**[ORD-READ-01] orders.get Tool** — Get single order by ID (3h)
- Implement `routers/orders.py::get_order()`:
  - Inputs: `order_id: str`, `store_name: str | None`
  - Resolve store (use active if store_name omitted)
  - Check cache first
  - Call OrderDesk API: `GET /orders/{order_id}`
  - Cache result (15s TTL)
  - Return: `{status, order: Order}`
- Add JSON schema with example
- Acceptance: Tool works, caching verified

**[ORD-READ-02] orders.list Parameters Schema** — Define all list parameters (2h)
- Implement `routers/orders.py::OrdersListParams`:
  ```python
  class OrdersListParams(BaseModel):
      store_name: str | None
      folder_id: str | None
      status: str | None
      since: datetime | None
      sort: str | None
      limit: int = Field(50, ge=1, le=250)
      page: int = Field(1, ge=1)
      search: str | None
      # Add ALL other documented OD params
  ```
- Validate against OrderDesk API docs
- Acceptance: Every OD param present, none invented

**[ORD-READ-03] orders.list Tool** — List orders with full control (4h)
- Implement `routers/orders.py::list_orders()`:
  - Input: `OrdersListParams`
  - Resolve store
  - Check cache (key by params hash)
  - Call OrderDesk API: `GET /orders?{params}`
  - Cache result (15s TTL)
  - Return: `{status, orders: [Order], total, page_info}`
- Acceptance: All params passed to OD, caching works

**[ORD-READ-04] store.get_settings Tool** — Get store config and folders (2h)
- Implement `routers/stores.py::get_settings()`:
  - Input: `store_name: str | None`
  - Call OrderDesk API: `GET /store`
  - Cache result (300s TTL)
  - Return: `{status, settings: {...}, folders: {...}}`
- Acceptance: Folder list available for other tools

**[ORD-READ-05] Orders Read Tests** — Test order read tools (3h)
- Write `tests/test_order_tools.py`:
  - `orders.get` with cache hit/miss
  - `orders.list` with default pagination
  - `orders.list` with custom limit/page
  - `orders.list` with filters (folder_id, status, since)
  - `store.get_settings` with cache
- Mock OrderDesk API responses
- Acceptance: 100% coverage, all params tested

**[ORD-READ-06] Pagination Edge Cases** — Test pagination boundaries (2h)
- Write `tests/test_pagination.py`:
  - Page beyond results (empty array)
  - Limit=1, limit=250
  - Invalid page (0, negative)
  - Invalid limit (0, >250)
- Acceptance: Edge cases handled gracefully

### Examples & Documentation

**[DOC-03] Order Read Examples** — Example requests (1h)
- Create `examples/orders_get.json`
- Create `examples/orders_list.json`
- Create `examples/store_get_settings.json`
- Each with request params and sample response
- Acceptance: Examples are copy-pasteable, valid JSON

---

## Phase 3: Full Mutation Pipeline

### Orders Write Operations

**[ORD-WRITE-01] orders.create Tool** — Create new order (3h)
- Implement `routers/orders.py::create_order()`:
  - Input: `OrderCreateParams` (all order fields)
  - Call OrderDesk API: `POST /orders`
  - Invalidate cache: `orders:list:*`
  - Return: `{status, order: Order}`
- Add JSON schema with all required fields
- Acceptance: Order created, cache invalidated

**[ORD-WRITE-02] orders.update_full Tool** — Replace entire order (3h)
- Implement `routers/orders.py::update_full()`:
  - Inputs: `order_id: str`, `order: Order`
  - Call OrderDesk API: `PUT /orders/{order_id}`
  - Invalidate cache: `order:{order_id}`, `orders:list:*`
  - Return: `{status, order: Order}`
- Warning in docs: prefer `orders.mutate_full` for safety
- Acceptance: Order replaced, cache invalidated

**[ORD-WRITE-03] orders.delete Tool** — Delete order (2h)
- Implement `routers/orders.py::delete_order()`:
  - Input: `order_id: str`
  - Call OrderDesk API: `DELETE /orders/{order_id}`
  - Invalidate cache: `order:{order_id}`, `orders:list:*`
  - Return: `{status, message}`
- Acceptance: Order deleted, cache invalidated

**[ORD-WRITE-04] Write Operations Tests** — Test create/update/delete (3h)
- Write `tests/test_order_writes.py`:
  - Create order
  - Update full order
  - Delete order
  - Cache invalidation verified for each
- Mock OrderDesk API responses
- Acceptance: 100% coverage, cache invalidation tested

### Mutation Engine

**[ORD-MUT-01] Deep Merge Logic** — Merge mutation into order (3h)
- Implement `services/mutation.py::apply_mutation()`:
  ```python
  def apply_mutation(order: Order, mutation: dict) -> Order:
      # Deep merge mutation into order.dict()
      # Handle nested objects (shipping, customer, order_items)
      # Return updated Order
  ```
- Preserve arrays unless explicitly replaced
- Acceptance: Merge logic correct for all field types

**[ORD-MUT-02] Typed Operations** — Define and apply mutation operations (3h)
- Implement `services/mutation.py` operations:
  ```python
  class MoveFolderOp(BaseModel):
      op: Literal["move_folder"]
      destination_folder_id: str
  
  class AddItemsOp(BaseModel):
      op: Literal["add_items"]
      items: list[OrderItem]
  
  class UpdateAddressOp(BaseModel):
      op: Literal["update_address"]
      address_type: Literal["shipping", "billing"]
      address: Address
  
  Operation = MoveFolderOp | AddItemsOp | UpdateAddressOp
  ```
- Implement `apply_operations(order, ops)` dispatcher
- Acceptance: Each operation type works correctly

**[ORD-MUT-03] Conflict Detection** — Detect concurrent modifications (2h)
- Implement `services/mutation.py::detect_conflict()`:
  ```python
  def detect_conflict(fetched: Order, uploaded: Order, error: dict | None) -> bool:
      # Compare date_updated timestamps
      # Or check OrderDesk error message for conflict indicator
      return fetched.date_updated != uploaded.date_updated
  ```
- Acceptance: Conflicts detected reliably

**[ORD-MUT-04] Mutation Retry Loop** — Retry on conflict with backoff (3h)
- Implement `services/mutation.py::mutate_order()`:
  ```python
  async def mutate_order(
      client: OrderDeskClient,
      order_id: str,
      mutation: dict | None,
      ops: list[Operation] | None,
      max_retries: int = 5
  ) -> Order:
      for attempt in range(max_retries):
          # 1. Fetch current order
          fetched = await client.get(f"orders/{order_id}")
          
          # 2. Apply mutation or ops
          updated = apply_mutation(fetched, mutation) if mutation else apply_operations(fetched, ops)
          
          # 3. Upload full order
          try:
              result = await client.put(f"orders/{order_id}", updated.dict())
              return Order(**result)
          except ConflictError:
              # Backoff: 500ms * 2^attempt + jitter
              await asyncio.sleep((0.5 * (2 ** attempt)) + random.uniform(0, 0.5))
              continue
      
      raise ConflictError(f"Max retries ({max_retries}) exceeded")
  ```
- Acceptance: Retries on conflict, backoff works, max retries honored

**[ORD-MUT-05] Mutation Engine Tests** — Test mutation logic (4h)
- Write `tests/test_mutation_engine.py`:
  - Deep merge: simple fields, nested objects, arrays
  - Typed operations: move_folder, add_items, update_address
  - Conflict detection
  - Retry loop with simulated conflicts (mock changing date_updated)
  - Max retries exceeded error
- Acceptance: 100% coverage, edge cases handled

### Orders Mutate Tool

**[ORD-MUT-06] orders.mutate_full Tool** — Safe mutation with retries (3h)
- Implement `routers/orders.py::mutate_full()`:
  ```python
  class OrderMutationParams(BaseModel):
      store_name: str | None
      order_id: str
      mutation: dict | None
      ops: list[Operation] | None
      
      @model_validator(mode="after")
      def validate_xor(self):
          if self.mutation and self.ops:
              raise ValueError("Provide mutation OR ops, not both")
          if not self.mutation and not self.ops:
              raise ValueError("Must provide mutation OR ops")
          return self
  
  async def mutate_full(params: OrderMutationParams) -> Result:
      # Call mutation engine
      # Invalidate cache on success
      # Return updated order
  ```
- Add JSON schema with examples (both mutation and ops)
- Acceptance: Tool works, retries on conflict, cache invalidated

**[ORD-MUT-07] orders.mutate_full Tests** — Test mutate tool (3h)
- Write `tests/test_mutate_full.py`:
  - Mutation with deep merge
  - Mutation with typed ops
  - Concurrent mutation retry (mock conflicts)
  - XOR validation (mutation vs ops)
  - Cache invalidation
- Acceptance: 100% coverage, concurrent mutations handled

### Convenience Mutation Wrappers

**[ORD-MUT-08] orders.move_folder Tool** — Move order(s) to folder (2h)
- Implement `routers/orders.py::move_folder()`:
  - Inputs: `order_ids: list[str]`, `destination_folder_id | destination_folder_name`
  - Call OrderDesk batch endpoint: `POST /move-orders`
  - Invalidate cache for each order
  - Return: `{status, results: [{order_id, message}]}`
- Add JSON schema
- Acceptance: Single and batch moves work

**[ORD-MUT-09] orders.add_items Tool** — Add items to order (2h)
- Implement `routers/orders.py::add_items()`:
  - Inputs: `order_id: str`, `items: list[OrderItem]`
  - Use `orders.mutate_full` internally with `AddItemsOp`
  - Return: `{status, order: Order}`
- Acceptance: Items added, mutation logic reused

**[ORD-MUT-10] orders.update_address Tool** — Update shipping/billing address (2h)
- Implement `routers/orders.py::update_address()`:
  - Inputs: `order_id`, `address_type: "shipping" | "billing"`, `address: Address`
  - Use `orders.mutate_full` internally with `UpdateAddressOp`
  - Return: `{status, order: Order}`
- Acceptance: Address updated, mutation logic reused

**[ORD-MUT-11] orders.create_history Tool** — Add history note (2h)
- Implement `routers/orders.py::create_history()`:
  - Inputs: `order_id: str`, `message: str`
  - Call OrderDesk API: `POST /orders/{order_id}/history` (check docs)
  - Return: `{status, message}`
- Acceptance: History note added

**[ORD-MUT-12] Convenience Wrappers Tests** — Test convenience tools (3h)
- Write `tests/test_order_convenience.py`:
  - Move single order
  - Move multiple orders (batch)
  - Add items
  - Update address (shipping and billing)
  - Create history note
- Acceptance: All wrappers work, use mutation engine correctly

### Examples & Documentation

**[DOC-04] Mutation Examples** — Example mutation requests (2h)
- Create `examples/orders_mutate_full_mutation.json` (deep merge example)
- Create `examples/orders_mutate_full_ops.json` (typed ops example)
- Create `examples/orders_move_folder.json`
- Create `examples/orders_add_items.json`
- Create `examples/orders_update_address.json`
- Acceptance: Examples demonstrate all mutation patterns

---

## Phase 4: Ancillary Resources

### Order Items Tools

**[ITEMS-01] order_items.list Tool** — Get all items for order (2h)
- Implement `routers/order_items.py::list_items()`:
  - Input: `order_id: str`
  - Call OD API: `GET /order-items/{order_id}` (check docs)
  - Cache (15s TTL)
  - Return: `{status, items: [OrderItem]}`
- Add JSON schema
- Acceptance: Items listed, cached

**[ITEMS-02] order_items.get Tool** — Get single order item (2h)
- Implement `routers/order_items.py::get_item()`:
  - Inputs: `order_id: str`, `item_id: str`
  - Call OD API: `GET /order-items/{order_id}/{item_id}` (check docs)
  - Cache (15s TTL)
- Acceptance: Single item fetched

**[ITEMS-03] order_items.create Tool** — Add item to order (2h)
- Implement `routers/order_items.py::create_item()`:
  - Inputs: `order_id: str`, `item: OrderItem`
  - Call OD API: `POST /order-items/{order_id}`
  - Invalidate cache
- Acceptance: Item added, cache invalidated

**[ITEMS-04] order_items.update Tool** — Update order item (2h)
- Implement `routers/order_items.py::update_item()`:
  - Inputs: `order_id`, `item_id`, `item: OrderItem`
  - Call OD API: `PUT /order-items/{order_id}/{item_id}`
  - Invalidate cache
- Acceptance: Item updated

**[ITEMS-05] order_items.delete Tool** — Remove item from order (2h)
- Implement `routers/order_items.py::delete_item()`:
  - Inputs: `order_id`, `item_id`
  - Call OD API: `DELETE /order-items/{order_id}/{item_id}`
  - Invalidate cache
- Acceptance: Item removed

**[ITEMS-06] Order Items Tests** — Test order items tools (2h)
- Write `tests/test_order_items.py`:
  - List items
  - Get single item
  - Create item
  - Update item
  - Delete item
  - Cache behavior
- Acceptance: 100% coverage

### Shipments Tools

**[SHIP-01] shipments.list Tool** — Get all shipments for order (2h)
- Implement `routers/shipments.py::list_shipments()`:
  - Input: `order_id: str`
  - Call OD API: `GET /shipments?order_id={order_id}`
  - Cache (15s TTL)
- Acceptance: Shipments listed

**[SHIP-02] shipments.get Tool** — Get single shipment (2h)
- Implement `routers/shipments.py::get_shipment()`:
  - Inputs: `order_id`, `shipment_id`
  - Call OD API: `GET /shipments/{shipment_id}`
  - Cache (15s TTL)
- Acceptance: Single shipment fetched

**[SHIP-03] shipments.create Tool** — Add shipment to order (2h)
- Implement `routers/shipments.py::create_shipment()`:
  - Inputs: `order_id`, `shipment: Shipment`
  - Call OD API: `POST /shipments`
  - Invalidate cache
- Acceptance: Shipment added

**[SHIP-04] shipments.update Tool** — Update shipment (2h)
- Implement `routers/shipments.py::update_shipment()`:
  - Inputs: `order_id`, `shipment_id`, `shipment: Shipment`
  - Call OD API: `PUT /shipments/{shipment_id}`
  - Invalidate cache
- Acceptance: Shipment updated

**[SHIP-05] shipments.delete Tool** — Remove shipment (2h)
- Implement `routers/shipments.py::delete_shipment()`:
  - Inputs: `order_id`, `shipment_id`
  - Call OD API: `DELETE /shipments/{shipment_id}`
  - Invalidate cache
- Acceptance: Shipment removed

**[SHIP-06] shipments.batch_create Tool** — Create multiple shipments (3h)
- Implement `routers/shipments.py::batch_create_shipments()`:
  - Input: `shipments: list[Shipment]`
  - Call OD API: `POST /batch-shipments` (check docs)
  - Invalidate cache
- Acceptance: Batch shipments created

**[SHIP-07] Shipments Tests** — Test shipments tools (2h)
- Write `tests/test_shipments.py`:
  - List shipments
  - Get single shipment
  - Create shipment
  - Update shipment
  - Delete shipment
  - Batch create
- Acceptance: 100% coverage

### Products/Inventory Tools

**[PROD-01] products.list Parameters Schema** — Define all list parameters (2h)
- Implement `routers/products.py::ProductsListParams`:
  ```python
  class ProductsListParams(BaseModel):
      store_name: str | None
      code: str | None  # SKU filter
      search: str | None
      limit: int = Field(50, ge=1, le=250)
      page: int = Field(1, ge=1)
      # Add ALL other documented OD params
  ```
- Validate against OD docs
- Acceptance: All OD params present

**[PROD-02] products.list Tool** — List inventory items (3h)
- Implement `routers/products.py::list_products()`:
  - Input: `ProductsListParams`
  - Call OD API: `GET /inventory-items?{params}`
  - Cache (60s TTL)
  - Return: `{status, products: [InventoryItem], total, page_info}`
- Acceptance: All params passed, cached

**[PROD-03] products.get Tool** — Get single inventory item (2h)
- Implement `routers/products.py::get_product()`:
  - Input: `id: str`
  - Call OD API: `GET /inventory-items/{id}`
  - Cache (60s TTL)
- Acceptance: Single product fetched

**[PROD-04] products.create Tool** — Create inventory item (2h)
- Implement `routers/products.py::create_product()`:
  - Input: `item: InventoryItem`
  - Call OD API: `POST /inventory-items`
  - Invalidate cache
- Acceptance: Product created

**[PROD-05] products.update Tool** — Update inventory item (2h)
- Implement `routers/products.py::update_product()`:
  - Inputs: `id: str`, `item: InventoryItem`
  - Call OD API: `PUT /inventory-items/{id}`
  - Invalidate cache
- Acceptance: Product updated

**[PROD-06] products.delete Tool** — Delete inventory item (2h)
- Implement `routers/products.py::delete_product()`:
  - Input: `id: str`
  - Call OD API: `DELETE /inventory-items/{id}`
  - Invalidate cache
- Acceptance: Product deleted

**[PROD-07] products.batch_update Tool** — Update multiple inventory items (3h)
- Implement `routers/products.py::batch_update_products()`:
  - Input: `items: list[InventoryItem]` (each with id)
  - Call OD API: `PUT /batch-inventory-items`
  - Invalidate cache
- Acceptance: Batch update works

**[PROD-08] Products Tests** — Test products tools (3h)
- Write `tests/test_products.py`:
  - List products with filters
  - Get single product
  - Create product
  - Update product
  - Delete product
  - Batch update
- Acceptance: 100% coverage

### Folders Tool

**[ANC-01] folders.list Tool** — Get folder structure (1h)
- Implement `routers/folders.py::list_folders()`:
  - Convenience wrapper around `store.get_settings`
  - Extract folders from settings
  - Return: `{status, folders: {id: name}}`
- Acceptance: Folders listed

### Examples

**[DOC-05] Ancillary Resource Examples** — Example requests (2h)
- Create `examples/order_items_create.json`
- Create `examples/shipments_create.json`
- Create `examples/products_list.json`
- Create `examples/products_create.json`
- Acceptance: Examples for each resource type

---

## Phase 5: Optional HTTP/SSE/WSS Adapter

**Note:** These tasks are OPTIONAL. Skip if only stdio transport is needed.

### FastAPI HTTP Adapter

**[HTTP-OPT-01] FastAPI App Setup** — Basic FastAPI app (2h)
- Create `mcp_server/http_adapter.py`:
  ```python
  app = FastAPI(title="OrderDesk MCP Server", version="0.1.0")
  ```
- Configure CORS (if needed)
- Lifespan events (startup/shutdown)
- Acceptance: App starts, serves root endpoint

**[HTTP-OPT-02] Health & Metrics Endpoints** — Operational endpoints (2h)
- Implement `/health`:
  - Return: `{status, version, uptime_seconds}`
- Implement `/metrics` (optional):
  - Prometheus format
  - Metrics: request_count, error_count, cache_hit_rate, etc.
- Acceptance: Endpoints return correct data

**[HTTP-OPT-03] SSE Transport** — Server-Sent Events for MCP (4h)
- Implement `GET /mcp/sse`:
  - Authenticate with Bearer token (master key)
  - Stream MCP messages via SSE
  - Handle client disconnects
- Acceptance: SSE transport works with MCP client

**[HTTP-OPT-04] WebSocket Transport** — Bidirectional MCP over WS (4h, optional)
- Implement `WebSocket /mcp/ws`:
  - Authenticate on connection
  - Bidirectional JSON-RPC messages
  - Handle disconnects and errors
- Acceptance: WS transport works with MCP client

**[HTTP-OPT-05] Webhook Receiver** — Receive OrderDesk webhooks (3h)
- Implement `POST /webhooks/orderdesk`:
  - Verify signature (if `WEBHOOK_SECRET` set)
  - Parse webhook payload
  - Trigger cache invalidation (if order/product webhook)
  - Return 200 OK
- Acceptance: Webhooks received, cache invalidated

**[HTTP-OPT-06] Proxy Header Middleware** — Parse proxy headers (2h)
- Implement `utils/proxy.py::get_client_ip()`:
  - If `TRUST_PROXY=true`: check `X-Forwarded-For`, `CF-Connecting-IP`
  - Else: use `request.client.host`
- Add middleware to inject `client_ip` into log context
- Acceptance: Client IP extracted correctly

**[HTTP-OPT-07] HTTP Adapter Tests** — Test HTTP endpoints (3h)
- Write `tests/test_http_adapter.py`:
  - Health endpoint
  - Metrics endpoint
  - SSE transport (if implemented)
  - Webhook receiver
  - Proxy headers
- Use `httpx.AsyncClient` or `TestClient`
- Acceptance: All endpoints tested

---

## Phase 6: Documentation & Examples

### User Documentation

**[DOC-01] README.md** — User-facing quickstart (6h)
- Write comprehensive README:
  - Project overview
  - Features list
  - Quickstart (<5 min to running server):
    - Installation (Docker or pip)
    - Generate `MCP_KMS_KEY`: `openssl rand -base64 32`
    - Run server: `docker-compose up` or `python -m mcp_server.main`
    - First tool call example
  - Tenancy model:
    - Master key concept
    - Store registration workflow
    - Session context usage
  - Pagination control:
    - Why explicit control matters
    - Example: `limit=25` vs default
  - Full-order mutations:
    - Why fetch → mutate → upload
    - Concurrency handling
    - When to use convenience wrappers
  - Cloudflare Tunnel setup
  - Troubleshooting section
  - Contributing guidelines
  - License
- Acceptance: First-time user can run server in <5 min

**[DOC-02] SETUP_GUIDE.md** — Detailed deployment guide (4h)
- Write `docs/SETUP_GUIDE.md`:
  - Local development setup
  - Docker Compose deployment
  - Cloud deployments:
    - Railway
    - Render
    - Fly.io
    - AWS ECS (advanced)
  - Cloudflare Tunnel configuration
  - Kubernetes deployment (advanced)
  - Environment variables reference (all vars)
  - Security best practices:
    - Master key rotation
    - API key storage verification
    - Log redaction verification
  - Monitoring and observability:
    - Log structure and fields
    - Metrics endpoint usage
    - Health check integration
- Acceptance: Covers all deployment scenarios

**[DOC-06] MCP_TOOLS_REFERENCE.md** — Complete tool catalog (6h)
- Write `docs/MCP_TOOLS_REFERENCE.md`:
  - Organized by category:
    - Tenant & Store Management (6 tools)
    - Orders Read (3 tools)
    - Orders Write (3 tools)
    - Orders Mutate (5 tools)
    - Order Items (5 tools)
    - Shipments (6 tools)
    - Products/Inventory (6 tools)
    - Store Settings (2 tools)
  - For each tool:
    - Tool name
    - Description (maps to which OD endpoint)
    - Parameters table (name, type, required, default, description)
    - Example request (JSON)
    - Example response (JSON)
    - Error cases and codes
- Acceptance: All 40+ tools documented with examples

**[DOC-07] operations.md** — Operations guide (4h)
- Write `docs/operations.md`:
  - Full-order update contract:
    - Why full updates only
    - Mutation semantics (deep merge)
    - Typed operations reference
  - Retry and concurrency:
    - Conflict detection mechanism
    - Retry strategy (exponential backoff)
    - Max retries configuration
  - Caching:
    - What's cached (orders, products, etc.)
    - TTLs per resource type
    - Invalidation strategy
    - Redis vs memory backend
  - Rate limiting:
    - Per-tenant limits (default 120 RPM)
    - OrderDesk API limits (leaky bucket)
    - Handling 429 responses
    - Best practices
  - Error handling:
    - Error codes reference
    - Common errors and solutions
- Acceptance: Operations team can use as runbook

### Configuration & Examples

**[DOC-08] .env.example Complete** — Full env var template (2h)
- Update `.env.example` with all variables:
  ```bash
  # Required
  MCP_KMS_KEY=  # base64-encoded 32-byte key, generate: openssl rand -base64 32
  
  # Server (optional)
  PORT=8080
  DATABASE_URL=sqlite:///data/app.db
  LOG_LEVEL=INFO
  
  # Security (optional)
  TRUST_PROXY=false
  RATE_LIMIT_RPM=120
  AUTO_PROVISION_TENANT=false
  WEBHOOK_SECRET=
  
  # Cache (optional)
  CACHE_BACKEND=memory  # memory|redis
  REDIS_URL=redis://localhost:6379/0
  CACHE_TTL_ORDERS=15
  CACHE_TTL_PRODUCTS=60
  
  # Resilience (optional)
  HTTP_TIMEOUT=30
  HTTP_MAX_RETRIES=3
  MUTATION_MAX_RETRIES=5
  ```
- Include description, type, default, security notes for each
- Acceptance: Every env var in code documented

**[DOC-09] Examples Directory Complete** — All tool examples (4h)
- Create example files for all tools:
  - Tenant/Store: `tenant_use_master_key.json`, `stores_register.json`, `stores_list.json`, `stores_use_store.json`
  - Orders Read: `orders_get.json`, `orders_list.json`, `orders_list_pagination.json`
  - Orders Write: `orders_create.json`, `orders_update_full.json`, `orders_delete.json`
  - Orders Mutate: `orders_mutate_full_mutation.json`, `orders_mutate_full_ops.json`, `orders_move_folder.json`, `orders_add_items.json`
  - Order Items: `order_items_create.json`, `order_items_update.json`
  - Shipments: `shipments_create.json`, `shipments_batch_create.json`
  - Products: `products_list.json`, `products_create.json`, `products_batch_update.json`
- Each file format:
  ```json
  {
    "description": "Human-readable description",
    "request": {
      // Tool parameters
    },
    "response": {
      // Expected response (or sample)
    },
    "notes": [
      "Additional usage notes"
    ]
  }
  ```
- Acceptance: Examples are valid, copy-pasteable

**[DOC-10] Postman Collection** — Optional HTTP collection (2h, optional)
- Export Postman collection with all tools (if HTTP adapter implemented)
- Include environment variables template
- Pre-request scripts for authentication
- Acceptance: Collection importable, all requests work

---

## Testing & Quality Assurance

### Integration Testing

**[TEST-INT-01] Orders Integration Test** — End-to-end order workflow (4h)
- Write `tests/integration/test_orders_integration.py`:
  - Requires env vars: `ORDERDESK_TEST_STORE_ID`, `ORDERDESK_TEST_API_KEY`
  - Workflow:
    1. Authenticate with master key
    2. Register test store
    3. List orders (`orders.list`)
    4. Create test order (`orders.create`)
    5. Get order (`orders.get`)
    6. Mutate order (`orders.mutate_full`)
    7. Move order to folder (`orders.move_folder`)
    8. Delete order (`orders.delete`)
  - Cleanup after test
- Guard with `pytest.mark.skipif(not ORDERDESK_TEST_ENABLED)`
- Acceptance: Full workflow passes against live OrderDesk API

**[TEST-INT-02] Products Integration Test** — Product CRUD workflow (2h)
- Write `tests/integration/test_products_integration.py`:
  - Create product
  - List products
  - Update product
  - Delete product
- Guard with env var check
- Acceptance: Product CRUD works against live API

**[TEST-INT-03] Cache Integration Test** — Cache behavior validation (2h)
- Write `tests/integration/test_cache_integration.py`:
  - Verify cache hit on repeated reads
  - Verify cache invalidation on writes
  - Verify TTL expiration
- Can use mock OrderDesk responses
- Acceptance: Cache behavior correct

### Load & Performance Testing

**[TEST-PERF-01] Load Testing Script** — Test rate limiting and retries (4h, optional)
- Write `tests/load/test_load.py`:
  - Spawn concurrent requests
  - Verify rate limiting kicks in
  - Verify retries on 429
  - Measure p95 latency
- Use `locust` or `vegeta`
- Acceptance: Server handles load gracefully

**[TEST-PERF-02] Cache Performance Benchmark** — Measure cache hit rates (2h, optional)
- Write benchmark script:
  - Measure cache hit/miss rates
  - Measure latency with/without cache
- Acceptance: Cache provides measurable speedup (>80% hit rate)

### Security Testing

**[TEST-SEC-01] Secret Redaction Test** — Verify no secrets in logs (2h)
- Write `tests/test_security.py`:
  - Trigger log messages with secrets in context
  - Parse logs and assert secrets are `[REDACTED]`
  - Test all sensitive fields (master_key, api_key, etc.)
- Acceptance: Zero secrets leak into logs

**[TEST-SEC-02] Encryption Roundtrip Test** — Verify crypto safety (1h)
- Write `tests/test_crypto_security.py`:
  - Verify encrypted data looks random (high entropy)
  - Verify decryption requires correct key
  - Verify tag tampering detected
- Acceptance: Crypto implementation secure

**[TEST-SEC-03] SQL Injection Test** — Input sanitization (2h, optional)
- Write `tests/test_sql_injection.py`:
  - Try SQL injection patterns in inputs
  - Verify SQLAlchemy parameterization prevents injection
- Acceptance: No SQL injection vectors

---

## Post-Development Tasks

### Release Preparation

**[REL-01] Version Tagging** — Tag v0.1.0-alpha (1h)
- Update version in `pyproject.toml`
- Create git tag: `git tag v0.1.0-alpha`
- Push tag: `git push origin v0.1.0-alpha`
- Acceptance: Tag created, CI builds release artifacts

**[REL-02] CHANGELOG.md** — Document changes (2h)
- Create `CHANGELOG.md` following Keep a Changelog format
- Document all features in v0.1.0-alpha
- Acceptance: Changelog complete and accurate

**[REL-03] Docker Registry Push** — Publish Docker image (2h)
- Configure Docker registry (Docker Hub, GHCR, etc.)
- CI job to build and push on tag
- Acceptance: Image pullable: `docker pull <registry>/orderdesk-mcp-server:v0.1.0-alpha`

**[REL-04] GitHub Release** — Create release with notes (1h)
- Create GitHub release for tag
- Include changelog
- Attach Docker Compose template
- Acceptance: Release published on GitHub

### User Testing

**[USER-01] First-Run Test** — Validate quickstart (<5 min) (2h)
- Have someone unfamiliar with project follow README
- Time from clone to working server
- Document pain points
- Acceptance: First-run success in <5 min

**[USER-02] Documentation Review** — External review (3h)
- Have external reviewer read all docs
- Collect feedback on clarity, completeness
- Revise docs based on feedback
- Acceptance: Documentation clarity rating >4/5

**[USER-03] Example Validation** — Test all examples (2h)
- Run every example in `/examples`
- Verify they work as documented
- Fix any broken examples
- Acceptance: 100% of examples work

---

## Summary Statistics

**Total Tasks:** ~150 tasks  
**Estimated Hours:** ~350-400 hours  
**Phases:** 7 (0-6)  
**Critical Path:** BOOT → SEC/DB/AUTH → HTTP/CACHE → ORD-READ → ORD-MUT → ANC → DOC

**Task Breakdown by Phase:**
- Phase 0 (Bootstrap & CI): ~25 tasks, ~35 hours
- Phase 1 (Auth, Storage, Session): ~30 tasks, ~60 hours
- Phase 2 (Order Read Path): ~20 tasks, ~40 hours
- Phase 3 (Mutation Pipeline): ~25 tasks, ~55 hours
- Phase 4 (Ancillary Resources): ~30 tasks, ~50 hours
- Phase 5 (HTTP/SSE/WSS - Optional): ~10 tasks, ~20 hours
- Phase 6 (Docs & Examples): ~20 tasks, ~40 hours
- Testing & QA: ~15 tasks, ~30 hours
- Release: ~7 tasks, ~15 hours

**Test Coverage Target:**
- Overall: >75%
- Critical paths (auth, mutation): >90%

**Documentation Pages:**
- README.md (user quickstart)
- SETUP_GUIDE.md (deployment)
- MCP_TOOLS_REFERENCE.md (tool catalog)
- operations.md (operations guide)
- .env.example (config reference)
- 30+ examples in `/examples`

---

## Task Assignment Workflow

For teams/contributors:

1. **Pick a task:** Find task marked `[TASK-ID]` in backlog
2. **Assign yourself:** Update task with your name
3. **Create branch:** `git checkout -b <TASK-ID>-short-description`
4. **Implement:** Follow acceptance criteria
5. **Test:** Ensure tests pass, coverage meets target
6. **Document:** Update docs if needed
7. **PR:** Create pull request, reference task ID
8. **Review:** Address feedback
9. **Merge:** Once approved and CI green

---

## References

### External
- **OrderDesk API:** https://apidocs.orderdesk.com/
- **MCP Protocol:** https://modelcontextprotocol.io/
- **Python Best Practices:** https://docs.python-guide.org/

### Internal
- [`speckit.constitution`](./speckit.constitution) - Design principles
- [`speckit.specify`](./speckit.specify) - Technical specification
- [`speckit.plan`](./speckit.plan) - Implementation plan

---

## Changelog

### v1.0.0 (2025-10-17)
- Initial task breakdown
- ~150 tasks defined with estimates
- Acceptance criteria for each task
- Organized by 7 phases

---

**END OF TASK BREAKDOWN**

